// решение курсанта натолкнуло меня на альтернативную идею выражения ковариантности

class Gcalc<T extends Expression> {

    // В данном случае, как и в решении курсанта тип-параметр определяет логику работы с values.
    // будет вызываться метод toString() у нужного типа(потомка) Expression
    public void covariantMethod(T[] values) {
        for (T value : values) {
            System.out.println(value.toString());
        }
    }

    public void polymorphicMethod(Expression value) {
        value.method();
    }

    public static void main(String[] args) {
        Gcalc<Expression> calc = new Gcalc();
        Expression[] expressions = new Expression[2];
        expressions[0] = new SimpleExpression();
        expressions[1] = new ComplexExpression();

        calc.covariantMethod(expressions);
        calc.polymorphicMethod(new SimpleExpression());
    }
}

class Expression {
    @Override
    public String toString() {
        return "some expression";
    }

    public void method() {
        System.out.println("some method from expression");
    }
}

class SimpleExpression extends Expression {
    @Override
    public String toString() {
        return "some simple expression";
    }

    @Override
    public void method() {
        System.out.println("some method from simple expression");
    }
}

class ComplexExpression extends SimpleExpression {
    @Override
    public String toString() {
        return "some complex expression";
    }

    @Override
    public void method() {
        System.out.println("some complex expression");
    }
}


class Calculator {
    Expression getExpression() {
        System.out.println("Некоторая логика простого калькулятора");
        return new Expression();
    }

    // В Java только массивы ковариантны,
    // остальные обобщенные коллекции использовать нельзя.
    public <T extends Expression> void covariantMethod(T[] values) {
        for (T value : values) {
            System.out.println(value.toString());
        }
    }

    // Можно передавать как объект типа Expression,
    // так и любого его потомка
    public void polymorphicMethod(Expression value) {
        value.method();
    }
}

class EngineeringCalculator extends Calculator {
    @Override
    SimpleExpression getExpression() {
        System.out.println("Некоторая логика инженерного калькулятора");
        return new SimpleExpression();
    }

    @Override
    public <T extends Expression> void covariantMethod(T[] values) {
        super.covariantMethod(values);
        System.out.println(values.length);
    }
}

class CursantSoluttion {

    public static void main(String[] args) {
        Calculator calculator = new EngineeringCalculator();
        Expression[] expressions = new Expression[2];
        expressions[0] = new SimpleExpression();
        expressions[1] = new ComplexExpression();

        // пример вызовы ковариантного метода (только для массивов)
        calculator.covariantMethod(expressions);

        // пример вызова полиморфного метода
        // передаем наследника класса Expression,
        // а не объект класса Expression
        calculator.polymorphicMethod(new SimpleExpression());
    }
}




