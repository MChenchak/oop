Решение курсанта

public abstract class Developer {
}

// Так делать плохо:
public class Worker extends Developer {
    public int skill; // -1 junior, 0 middle, 1 senior

    public Worker(int skill){
        this.skill = skill;
    }
}


// Лучше делать так:
public class Senior extends Developer {
}

public class Middle extends Developer {
}

public class Junior extends Developer {
}

// Теперь наш код открыт для расширений, но закрыт для изменений,
// и с точки зрения семантики так куда лучше :)

Второй вариант соответствует правилам и рекомендациям из занятия.
Свойство skill может принимать любые значения типа int. Если возникнет желание ввести дополнительные квалификационные уровни,
то нет проблем. Достаточно присвоить этому уровню числовой код типа int.

Но, во-первых, такой подход элементарно не нагляден. Особенно, если уровней будет много.
Во-вторых, если от skill будет зависеть выполнение какого-то метода класса Worker, то внутри этого метода появится
конуструкция if - else, и она будет тем длиннее, чем больше уровней skill. Это верный признак плохого проектирования.

Поэтому лучшим вариантом будет наследование с переопределением методов для каждого уровня разработчика.

Альтернативным вариантом может быть создание типа, например, Qualification, который уже будет расширяться уровнями.
А поле этого типа будет добавлено в класс Developer.